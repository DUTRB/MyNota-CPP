# C++ 语言基础

## 1. 介绍四种智能指针

- 为什么引入智能指针，智能指针是什么？

智能指针的作用是管理一个指针，避免指针指向的内存空间在函数结束时忘记释放，造成内存泄露问题。

智能指针实际上是一个类，在创建时会申请内存并初始化，当超出函数作用域时，会自动调用析构函数，释放内存空间。

所有智能指针的核心作用原理就是：在函数结束时，自动释放指针资源，不需要程序员手动释放。

分别为哪四种？

1. auto_ptr (c98使用) 采用所有权模式

```
auto_ptr<std::string> str1(new string("hello"));
auto_ptr<std::string> str2;
str2 = str1;
```

这种方式会在复制时，转移str1的全部所有权，这可能导致资源管理不当，出现内存泄露问题。

2. unique_ptr 独占指针

实现独占式拥有，在同一时间只能有一个 unique_ptr 指向该对象，对避免资源泄露管用。

```
unique_ptr<std::string> str1(new string("hello"));
unique_ptr<std::string> str2;
// str2 = str1; // 会直接报错
```

这会避免 str1 指向其他未知数据的风险。比 auto_ptr 更加安全。

3. shared_ptr 共享指针

允许多个共享指针指向同一个对象，该对象和相关资源会在最后一个共享指针被销毁时释放。内部使用引用计数机制来记录资源被多少指针占用。

```
shared_ptr<std::string> str3(new string ("world"));
```

当引用计数变为0时，释放资源。可使用 use_count() 查看引用计数个数。除了使用 new 来构造，还可以通过 unique_ptr或者weak_ptr来构造实现。

当我们调用 release()时，当前指针会释放资源所有权，引用计数-1。

```
unique_ptr<std::int> num1(new int(10));
shared_ptr<std::int> num2(num1);
```

4. weak_ptr 弱引用

主要是为了解决两个shared_ptr互相引用导致各自的引用计数无法变为0的问题，造成资源无法释放。解决办法为将其中一个变为 weak_ptr即可。

它只指向 shared_ptr管理的对象，对该对象进行内存管理的主要还是对应的 shared_ptr;

weak_ptr只提供了对管理对象的一个访问手段，设计目的也是为了配合 shared_ptr进行工作，通过另一个weak_ptr或者shared_ptr构造后，该对象的引用计数不会增加。

```c++
#include <memory>
#include <iostream>

class Test {
public:
    ~Test() {
        std::cout << "Test object destroyed" << std::endl;
    }
};

int main() {
    std::shared_ptr<Test> ptr1(new Test());
    std::weak_ptr<Test> ptr2; // ptr2 声明为 weak_ptr

    {
        std::shared_ptr<Test> ptr3 = ptr1;
        // ptr1 和 ptr3 互相引用，形成循环引用
        ptr1 = ptr3;
        // ptr2 现在持有 weak_ptr，不会导致循环引用问题
        ptr2 = ptr1;
        // 离开作用域后 ptr3会被删除
    }
    
    // ptr2 作为 weak_ptr，不会阻止对象的销毁
    std::cout << "ptr1 and ptr3 destroyed, checking if ptr2 is expired: " << std::boolalpha << ptr2.expired() << std::endl;

    // 尝试从 weak_ptr 获取 shared_ptr
    std::shared_ptr<Test> lockedPtr = ptr2.lock();
    // std::weak_ptr::lock() 函数的作用是尝试获取一个 std::shared_ptr，
    // 该 std::shared_ptr 与调用 lock() 的 std::weak_ptr 指向同一个对象。
    if (lockedPtr) {
        // 如果对象未被销毁，重新获得控制权
        std::cout << "Reacquired control of Test object" << std::endl;
    } else {
        std::cout << "Test object has been destroyed" << std::endl;
    }

    return 0;
}
```

运行结果：

> /> ptr1 and ptr3 destroyed, checking if ptr2 is expired: false
> /> Reacquired control of Test object
> /> Test object destroyed

<img src="八股笔记.assets/image-20240512152000223.png" alt="image-20240512152000223" style="zoom:67%;" />

## 2. C++ 中的内存分配情况

<img src="八股笔记.assets/image-20240513091437834.png" alt="image-20240513091437834" style="zoom:67%;" />

- 栈：由编译器负责管理，存储函数参数和局部变量。
- 堆：由程序员申请和释放，使用new和delete操作管理。
- 数据段：也称为全局、静态存储区，存放全局变量和静态变量，分为初始化部分和未初始化部分。
- 代码段：存放程序的二进制代码，使得CPU不用一直从硬盘读取程序。

## 3. C++ 中的指针参数传递和引用参数传递

- 指针参数传递：实际上还是值传递，通过指针的方式传入进来的实参的地址值。传入后形参会作为局部变量处理，同时在栈内申请内存空间，存放传入变量的副本，实际上是复制了一份数据再存储供函数体内部使用。

	这种方式的特点是：调用函数对传入变量的修改都是在对栈中存放的副本数据进行修改，并不会影响实参的值。

- 引用参数传递：同样也是在栈中开辟内存空间，但此时存放的是实参的地址，函数体内部对于该变量的修改都会实际影响到是实参的值。

	被调函数对形参的任何操作都看做是间接寻址，通过栈内存放的地址值再找到实参。引用的方式有助于节省内存，尤其是传入的对象是类等数据结构。

从编译的角度来讲，在编译阶段，分别将指针和引用存储到符号表中，符号表记录的是变量名以及变量所在地址。

指针变量在符号表中记录的是指针变量自身的地址值；而引用在符号表中记录的是引用对象的地址值（与实参名字不同，但地址相同）。

符号表生成后就不会再修改，因此指针可以改变指向的对象，而引用对象不能进行修改。

## 4. C++ 中const和static关键字

1. static ： 控制变量的存储方式和可见性

- 修饰局部变量：在函数体内部的变量加上static修饰后，会将变量存储区域从栈区变为静态存储区，原来变量在函数体结束后就会释放，修饰后将生命周期延长至整个程序运行周期。但注意的是其作用域不会改变，仍为函数体内部。

- 修饰全局变量：修改变量的作用域，从整个工程可见变为了仅本文件可见。如果没有加static修饰，在其他文件中包含头文件即可使用该全局变量。
- 修饰函数：与修饰全局变量类似，也是修改函数作用域。
- 修饰类内成员或变量：如果修饰类内函数，说明该函数属于类，而不属于此类的任何特定对象。如果对类内变量加static修饰，则表明该变量在内存空间中仅有一个副本，不属于任何对象或实例，可供类和对象调用。静态成员函数不接受this指针，因此不能访问非静态成员函数。

2. const 关键字

- 修饰基本数据类型：表示该类型为只读，不可以进行修改。

- 修饰指针变量和引用变量：

- 修饰函数传入参数：通常使用const& 的方式来保护传入参数变量不被修改，防止传入后实参被调用函数内部错误修改。

- 在类中修饰成员变量：表示在类的实例生命对象期间不可修改。const 数据成员的初始化只能在类的构造函数初始化列表中实现。

- 在类中修饰成员函数：防止成员函数修改对象的内容。在函数内部只读不可修改。

- 修饰类对象：定义常量对象，只能调用常量函数。

	- ```c++
		class MyClass {
		public:
		    MyClass(int val) : value(val) {}
		
		    // 非 const 成员函数，可以修改对象状态
		    void NonConstFunc() {
		        value++;
		    }
		    // const 成员函数，保证不修改对象状态
		    void ConstFunc() const {
		        // value++; // 错误：不能修改 const 对象的状态
		    }
		    int GetValue() const {
		        return value;
		    }
		
		private:
		    int value;
		};
		
		int main() {
		    const MyClass constObj(10); // 定义了一个 const 对象
		    constObj.ConstFunc(); // 正确：可以调用 const 成员函数
		    // constObj.NonConstFunc(); // 错误：不能调用非 const 成员函数
		    return 0;
		}
		```

## 5. C和C++区别



